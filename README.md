# awkward-proxy
  基于公司代理的白名单域名上访问互联网，解决部分访问互联网的限制，也就是内网办公的限制。

## 1、背景
  目前有一些传统但又打着互联网的公司经常会做一些愚蠢且无聊的事情。已经2020年了，还是有不少公司是内网办公的，传统的银行，金融，安全类的公司就是这样操作的，不给员工上外网，这个还能理解。但是一些号称大厂，IT一线公司，还是不给上外网，那么怎么解决这个问题？解决的前提是你得能访问一些代理白名单的外网，一般这样的公司都会预留一些域名白名单的来允许你访问部分的网站，比如允许你访问CSDN，访问微信开发者中心等一些常用的技术网站，如果这些都没有，那么就不用看下去了。

## 2、实现的思路
如图：
 ![image](https://github.com/traceless/awkward-proxy/blob/master/WX20220328.png)

1. 把内网pc的请求信息存放到白名单的互联网文章A中，通常请求信息有url, param/body, header等
2. 外网pc定时从文章A拿到请求信息体，然后通过外网请求链接获取内容
3. 将获取到的内容写入到文章B中，通常就是包含header，body信息等
4. 内网pc定时从文章B获取到响应信息，然后返回给浏览器

## 3、具体实现细节

### 客户端client.js
- 所有浏览器请求先存放到requestArray中，然后定时把请求信息列表写入文章req中
- 定时获取文章res内容，把内容存放到responseArray
- 然后等待轮询responseArray, 根据reqId匹配对应的响应进行处理，主要是把html的url全部替换成http，返回给浏览器

### 服务端server.js
- 定时获取文章req内容，解析得到requestArray，遍历requestArray，请求url链接的内容，并且存放到resultResponse数组中
- 定时把resultResponse内容写入到文章res中，客户端会定时拉取这些响应

## 4、配置信息
1. 例子中使用的是微信公众平台的文章，所以需要公众号账号，登录后获取cookie和token，然后需要素材文章的appmsgid 2个，一个请求，一个响应。
2. 测试时候可以使用本地的文件作为中间交互的载体
3. 设置浏览器的代理服务器为本地的client开发的端口
4. 避免被中间人挟持，可以配置Base64的secret。当然也可以使用对称加密后再转标准base64字符，自由修改函数的实现，这里提供的是实现的思路。

### 运行
1. npm i 安装必要的模块
2. 内网pc执行 node client.js （然后电脑的浏览器配置代理的使用client.js暴露的端口）
3. 外网pc执行 node server.js (也可以使用在手机上执行)

## 5、注意
1. 例子中使用的是微信公众平台的文章作为中间存放信息交互的载体。目前还不支持https代理，不过已经做了折中的方式，如果要访问https的网站，请变通比如 http://www.baidu.com/_sssss, 给域名添加后缀来解决。因为https的代理比较复杂，我这里就不做太复杂的实现了。按思路理论上可以实现sock5代理，目前实现的sock5代理效果不行，不过它能用，还能看视频，大家可以本地测试下，很慢20s+，慢的离谱，大家可以自行优化一下。。。
2. 目前看来实现http就已经很慢了，假如2秒定时轮询的话，访问一个网页大概需要10+秒加载完成，反正总比没有要强把，理论上比正常上网慢4-6秒。如果外网域名有暴露推送的接口，那么速度会快很多，思路都差不多，自行实现。里面有不少的bug，主要是一些网站的js会做加密，无法解析替换https，小问题还是挺多的，整体可用。你也可以把一些域名限制，默认所有链接默认走https，但还是无法解决js加密问题，sock5全代理则无这样的问题。
3. 暂时没实现上传的支持，看看源码请自行实现，不难。下载文件理论上可以的，还没测试过。不过按文章存放的字数限制来说，测试过2.5M文件转base64能存到单个文章中（其实也可以放到多个文章中，之前测试过可以，大家自行实现即可），更大的10M就挂了，其他大小没测试了，反正当下载没啥必要。
4. BTW: base64是比较方便的编码设计，这次案例中学到了编码的姿势。
